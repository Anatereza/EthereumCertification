// SPDX-License-Identifier: MIT
pragma solidity >=0.4.21 <0.8.0;

import {LibConcatenateStrings} from './LibConcatenateStrings.sol';
import {LibTransformUintString} from "./LibTransformUintString.sol";


/*
    Libraries
 */

/*
library ConcatenateStrings {
    // Function to concatenate two strings
    function concatenate(string memory a, string  memory b) public pure returns(string memory) {
        return string(abi.encodePacked(a, b));
    }
}

library TransformUintString {
    // Function to transform a uint to a string
    function uintToString(uint v) public pure returns (string memory str) {
        uint maxlength = 100;
        bytes memory reversed = new bytes(maxlength);
        uint i = 0;
        while (v != 0) {
            uint remainder = v % 10;
            v = v / 10;
            reversed[i++] = byte(uint8(48 + remainder));
        }
        bytes memory s = new bytes(i + 1);
        for (uint j = 0; j <= i; j++) {
            s[j] = reversed[i - j];
        }
        str = string(s);
    }    
}
*/
    /*
        The CivilState contract keeps track of the citizen information, starting from their birth and being maintained throughout their life
     */
contract CivilState {
    using LibConcatenateStrings for *;
    using LibTransformUintString for *;

    /*
        Public owner variable => the creator of the contract when it is initialized.
    */
    address public owner;

    /*
        Birth struct : add birth information
    */
    struct Birth {
        string name;
        string lastName;
        string birthDate;
        string birthCity;
        bool isVerified;
    }

    /*
        Identity struct : created to validate a birth and create the citizen identity
    */
    struct Identity {
        Birth birthinfo;
        
        // Marital information
        string maritalStatus;
        string marriageDate;
        string userLogin;
    }

    /*
        Identifier struct : created to track users identifiers
    */
    struct Identifier {
        uint userIdentityCount;
        bytes32 userPassword;
        bytes32 newCertification;
    }

    /*
        Authentification struct : created to track hospital, prefecture and city hall members authentification
    */    
    struct Authentification {
        string login;
        string name;
    }
    
    /*
        Mapping to keep track of the hospital members
    */
    mapping (address => Authentification) hospitalMembers;

    /*
        Mapping to keep track of the prefecture members
    */
    mapping (address => Authentification) prefectureMembers;

    /*
        Mapping to keep track of the city hall members
    */
    mapping (address => Authentification) cityHallMembers;

    /*
       Mapping to keep track of the births
    */
    mapping (uint => Birth) births;
    uint birthsCount = 0;

    /*
       Mapping to keep track of the citizen's identities
    */    
    mapping (uint => Identity) identities;
    uint identitiesCount = 0;

    /*
        Mapping to keep track of citizen's identifiers
    */
    mapping(string => Identifier) citizenIdentifiers;

    /*
        Mapping to keep track of identity certifications generated by users (citizens)
    */
    mapping(bytes32 => Identifier) idCertifications;

    // Events

    // Event signaling that a new hospital member was added
    event LogEventAddHospitalMember(string memberName);
    // Event signaling that a new prefecture member was added
    event LogEventAddPrefectureMember(string memberName);
    // Event signaling that a new cityHall member was added
    event LogEventAddCityHallMember(string memberName);
    // Event signaling that a new birth member was declared
    event LogEventBirthAdded (string name, string lastName, uint birthId);
    // Event signaling that a new identity was verified
    event LogEventVerifyIdentity(uint birthId, uint identityId);
    // Event signaling that new marriage member was declared
    event LogEventDeclareMarriage(string marriageDate, uint identityId);
    // Event signaling that a certification was generated
    event LogEventCertificationGenerated(string login, bytes32 identity_hash);


    /*
       Modifier that throws an error if the msg.sender is not the owner.
    */
    modifier isAdmin () {
        require(owner == msg.sender);
        _;
    }

    /*
       Modifier that throws an error if the msg.sender passed is not a hospital member.
    */
    modifier isHospital () {
        require (bytes(hospitalMembers[msg.sender].name).length > 0);
        _;
    }

    /*
       Modifier that throws an error if the msg.sender passed is not a prefecture member.
    */
    modifier isPrefecture () {
        require (bytes(prefectureMembers[msg.sender].name).length > 0);
        _;
    }

    /*
       Modifier that throws an error if the msg.sender passed is not a city hall member.
    */
    modifier isCityHall () {
        require (bytes(cityHallMembers[msg.sender].name).length > 0);
        _;
    }

    constructor () public {
        owner = msg.sender;
    }
    
    // Help functions 
    /* use library instead
    // Function to concatenate strings
    function concatenate(string memory a, string  memory b) public pure returns(string memory) {
            return string(abi.encodePacked(a, b));
    }

    // Function to transform uint to string
    function uintToString(uint v) public pure returns (string memory str) {
        uint maxlength = 100;
        bytes memory reversed = new bytes(maxlength);
        uint i = 0;
        while (v != 0) {
            uint remainder = v % 10;
            v = v / 10;
            reversed[i++] = byte(uint8(48 + remainder));
        }
        bytes memory s = new bytes(i + 1);
        for (uint j = 0; j <= i; j++) {
            s[j] = reversed[i - j];
        }
        str = string(s);
    }*/
    
    // Admin functions

    /* 
        Function do add a new hospital member to the "hospitalMembers" mapping
        Only the owner of the contract (the admin) can add new members
    */
    function addHospitalMember (address _newMember, string memory _memberName) public isAdmin {
        // Initialization of login
        string memory login = "login_";
        string memory _login = login.concatenate( _memberName);       
        hospitalMembers[_newMember] = Authentification({
            login : _login,
            name : _memberName
        });
        emit LogEventAddHospitalMember(_memberName);
    }

    /* 
        Function do add a new prefecture member to the "prefectureMembers" mapping
        Only the owner of the contract (the admin) can add new members
    */
    function addPrefectureMember (address _newMember, string memory _memberName) public isAdmin {
        // Initialization of login
        string memory login = "login_";
        string memory _login = login.concatenate(_memberName); 
        prefectureMembers[_newMember] = Authentification({
            login : _login,
            name : _memberName
        });
        emit LogEventAddPrefectureMember(_memberName);
    }

    /* 
        Function do add a new city hall member to the "cityHallMembers" mapping
        Only the owner of the contract (the admin) can add new members
    */
    function addCityHallMember (address _newMember, string memory _memberName) public isAdmin {
        // Initialization of login
        string memory login = "login_";
        string memory _login = login.concatenate(_memberName); 
        cityHallMembers[_newMember] = Authentification({
            login : _login,
            name : _memberName
        });
        emit LogEventAddCityHallMember(_memberName);
    }

    /*
        Function to add a new birth
        When there is a birth, a member of the hospital must declare the birth : this function creates a new birth
        Only a hospital member can create a new birth
    */      
    function addBirth (string memory _name, string memory _lastName, string memory _birthDate, string memory _birthCity) public isHospital returns(uint) {
        uint birthId = birthsCount++;
        births[birthId] = Birth({
            name : _name,
            lastName : _lastName,
            birthDate : _birthDate,
            birthCity : _birthCity,
            isVerified : false
        });
        emit LogEventBirthAdded(_name, _lastName, birthId);
        return birthId;
    }

    // Function to get the birthId after the creation of a new birth
    function getBirthId () public view returns (uint _birthId, string memory _name, string memory _lastName){
        _name = "undefined";
        _lastName = "undefined";
        if (birthsCount >= 0) {
            _birthId = birthsCount - 1;
            _name = births[_birthId].name;
            _lastName = births[_birthId].lastName;
        }    
    }
    
    /*
        Function to verify an identity  
        After a birth declaration, the a member of the prefecture must verifiy the citizen's identity
        Only a member of the prefecture can verify an identity
    */
    function verifyIdentity (uint birthId) public isPrefecture returns (uint identityId) {
        require(births[birthId].isVerified == false);
        births[birthId].isVerified = true;
        
        // Initialization of login and password
        string memory login = "login_";
        string memory _login = login.concatenate(births[birthId].lastName); 
        login = _login.concatenate(births[birthId].birthDate);        
        
        string memory pwd = "pwd_";
        string memory password = pwd.concatenate(births[birthId].birthDate);
        bytes32 passwordHash = keccak256(bytes(password));

        bytes32 lambdaCertification = keccak256(bytes("new"));

        identityId = identitiesCount++;
        identities[identityId] = Identity({
            birthinfo : births[birthId],
            maritalStatus : "single",
            marriageDate: "",
            userLogin: login
        });

        citizenIdentifiers[login] = Identifier({
            userIdentityCount : identityId,
            userPassword : passwordHash,
            newCertification : lambdaCertification
        });

        emit LogEventVerifyIdentity(birthId, identityId);
    }

    // Function to get the identityId after the verification of an identity
    function getIdentityId() public view returns (uint _identity, string memory _name, string memory _lastName){
        _name = "undefined";
        _lastName = "undefined";
        if (identitiesCount >= 0) {
            _identity = identitiesCount - 1;
            _name = identities[_identity].birthinfo.name;
            _lastName = identities[_identity].birthinfo.lastName;            
        } 
    }

    /*
        Function to declare a marriage
        Only a city Hall member can declare a marriage
    */
    function declareMarriage (uint identityId, string memory _marriageDate) public isCityHall {
        require(identities[identityId].birthinfo.isVerified == true);
        
        //Change marital status
        identities[identityId].maritalStatus = "married";
        identities[identityId].marriageDate = _marriageDate;

        emit LogEventDeclareMarriage(_marriageDate, identityId);
    }

    /*
        Function to allow citizens to modify their password
    */
    function modifyMyPassword (string memory _login, string memory _oldPwd, string memory _newPwd) public{
        //Verify that the user used the good password
        require (citizenIdentifiers[_login].userPassword == keccak256(bytes(_oldPwd)));
        bytes32 newPwd = keccak256(bytes(_newPwd));
        citizenIdentifiers[_login].userPassword = newPwd;
    }

    /*
        Function to allow citizen to generete an identity certification
    */
    function generateIdCertification (string memory login, string memory pwd) public returns (bytes32){
        //Verify that the user used the good password
        require (citizenIdentifiers[login].userPassword == keccak256(bytes(pwd)));
        // Get the user identity count
        uint userIdCount = citizenIdentifiers[login].userIdentityCount;
        string memory userIdCountString = userIdCount.uintToString();
        string memory contIdentifiers = userIdCountString.concatenate(pwd);
        bytes32 identity_hash = keccak256(bytes(contIdentifiers));
        citizenIdentifiers[login].newCertification = identity_hash;
        // add certification to mapping
        idCertifications[identity_hash] = citizenIdentifiers[login];
        emit LogEventCertificationGenerated(login, identity_hash);
        return identity_hash;
    }
    
    // Function to get the lastCertification
    function getCertification(string memory _login) public view returns (bytes32) {
        return citizenIdentifiers[_login].newCertification;
    }
    

    /*
       Functions read
    */

    /*
        Function to verify identityCertification
        Once a citizen generates a certification, anyone who has the hash of the certification can verify the identity
    */

    function verifyCertification (bytes32 id_hash) public view returns (string memory _name, string memory _lastName, string memory _birthDate, string memory _birthCity, string memory _maritalStatus) {
        // get userIdCount
        uint userIdCount = idCertifications[id_hash].userIdentityCount;
        return(identities[userIdCount].birthinfo.name, identities[userIdCount].birthinfo.lastName, identities[userIdCount].birthinfo.birthDate, identities[userIdCount].birthinfo.birthCity, identities[userIdCount].maritalStatus);

    }
    
    // Function to read a birth information
    function readBirth(uint birthId) public view returns(string memory _name, string memory _lastName, string memory _birthDate, string memory _birthCity, bool _isVerified){
        return (births[birthId].name, births[birthId].lastName, births[birthId].birthDate, births[birthId].birthCity, births[birthId].isVerified);
    }        

    // Function to read an identity information
    function readIdentity(uint identityId) public view returns(string memory _name, string memory _lastName, string memory _birthDate, string memory _birthCity, string memory _maritalStatus){
        require(identities[identityId].birthinfo.isVerified == true);
        return (identities[identityId].birthinfo.name, identities[identityId].birthinfo.lastName, identities[identityId].birthinfo.birthDate, identities[identityId].birthinfo.birthCity, identities[identityId].maritalStatus);
    }

    // Function to get the births count
    function getBirthsCount() public view returns(uint _birthCount) {
        return birthsCount; 
    }

    // Function to get the identities count
    function getIdentitiesCount() public view returns(uint _identitiesCount){
        return identitiesCount;
    }

    // Function to get the owner of the contract
    function getOwner() public view returns(address _owner){
        return owner;
    }

    /* 
        Function to verify if the msg.sender is a hospital member
        Return 0x00..0 if not a hospital member
        Return the address of the msg.sender if it is a hospital member
    */
    function isHospitalMember() public view returns(address){
        address memberAddress;
        if (bytes(hospitalMembers[msg.sender].name).length > 0) {
            memberAddress = msg.sender;
        } else {
            memberAddress = 0x0000000000000000000000000000000000000000;
        }
        return memberAddress;
    }

    /* 
        Function to verify if the msg.sender is a prefecture member
        Return 0x00..0 if not a prefecture member
        Return the address of the msg.sender if it is a prefecture member
    */
    function isPrefectureMember() public view returns(address){
        address memberAddress;
        if (bytes(prefectureMembers[msg.sender].name).length > 0) {
            memberAddress = msg.sender;
        } else {
            memberAddress = 0x0000000000000000000000000000000000000000;
        }
        return memberAddress;
    }

    /* 
        Function to verify if the msg.sender is a city hall member
        Return 0x00..0 if not a city hall member
        Return the address of the msg.sender if it is a city hall member
    */
    function isCityHallMember() public view returns(address){
        address memberAddress;
        if (bytes(cityHallMembers[msg.sender].name).length > 0) {
            memberAddress = msg.sender;
        } else {
            memberAddress = 0x0000000000000000000000000000000000000000;
        }
        return memberAddress;
    }

}