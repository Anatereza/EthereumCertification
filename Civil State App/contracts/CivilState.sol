// SPDX-License-Identifier: MIT
pragma solidity >=0.4.21 <0.8.0;

/* 
* Libraries needed in the contract 'Civil State' contract
*/
/** @title LibConcatenateStrings. */
/// @dev Library with a function for concatenating strings
import {LibConcatenateStrings} from './LibConcatenateStrings.sol';
/** @title LibTransformUintString. */
/// @dev Library with a function to transform an 'uint' in a 'string
import {LibTransformUintString} from './LibTransformUintString.sol';
/** @title SafeMath. */
/** 
 * @dev Library with functions to realize arithmetic operations with overflow checks
 *
 * Contract collection retrieved from : https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol
 *
*/
import {SafeMath} from './SafeMath.sol';

/** @title CivilState. */
contract CivilState {
    /// @dev Include libraries codes and initialize its use in the contract
    using LibConcatenateStrings for string;
    using LibTransformUintString for *;
    using SafeMath for uint; 

    /**
     * @dev State variable to allow contract functionnlity to be stopped
     * For implementing circuit breaker pattern
     */ 
    bool public stopped = false;
    
    /// @dev Owner address
    address payable public owner;

    /** 
    * @dev Contains the birth elements 
    * Elements : name, last name, birth date, birth city and verification status
    */
    struct Birth {
        string name;
        string lastName;
        string birthDate;
        string birthCity;
        bool isVerified;
    }

    /** 
    * @dev Contains the identity elements 
    * Elements : information from the birth, marital status, marriage date and user login
    */    
    struct Identity {
        Birth birthinfo;
        string maritalStatus;
        string marriageDate;
        string userLogin;
    }

    /** 
    * @dev Contains users (citizens) identifiers 
    * Elements : 
    *   - Identification number
    *   - Hash of the user's password
    *   - Hash of the last certification generated by the user
    */    
    struct Identifier {
        uint userIdentityCount;
        bytes32 userPassword;
        bytes32 newCertification;
    }

    /** 
    * @dev Contains hospital, prefecture and city hall members authentification information
    * Elements : member login, member name
    */    
    struct Authentification {
        string login;
        string name;
    }
    
    
    /// @dev Maps hospital members addresses to their authentification information
    mapping (address => Authentification) hospitalMembers;

    /// @dev Maps prefecture members addresses to their authentification information
    mapping (address => Authentification) prefectureMembers;

    /// @dev Maps city hall members addresses to their authentification information
    mapping (address => Authentification) cityHallMembers;

    /// @dev Maps births identifications to the birth information
    mapping (uint => Birth) births;
    uint birthsCount = 0;

    /// @dev Maps identities identifications to the identity (citizen) information 
    mapping (uint => Identity) identities;
    uint identitiesCount = 0;

    /// @dev Maps user login (string) to the user identifier
    mapping(string => Identifier) citizenIdentifiers;

    /// @dev Maps user certification hash (bytes32) to the user identifier
    mapping(bytes32 => Identifier) idCertifications;

    /**
     * Events
     */ 
    /// @dev Event signaling that a new hospital member was added
    event LogEventAddHospitalMember(string memberName);
    /// @dev Event signaling that a new prefecture member was added
    event LogEventAddPrefectureMember(string memberName);
    /// @dev Event signaling that a new cityHall member was added
    event LogEventAddCityHallMember(string memberName);
    /// @dev Event signaling that a new birth member was declared
    event LogEventBirthAdded (string name, string lastName, uint birthId);
    /// @dev Event signaling that a new identity was verified
    event LogEventVerifyIdentity(uint birthId, uint identityId);
    /// @dev Event signaling that new marriage member was declared
    event LogEventDeclareMarriage(string marriageDate, uint identityId);
    /// @dev Event signaling that a certification was generated
    event LogEventCertificationGenerated(string login, bytes32 identity_hash);
    /// @dev Event verifying a certification
    event LogEventVerifyCertification (string name, string lastName, string birthDate, string birthCity, string maritalStatus);

    /**
     * Modifiers
     */ 

    /**
     * @dev Permit certain functions only when 'stopped' is false
     * Circuit breaker pattern
     */
    modifier stopInEmergency { 
        require(!stopped); _; 
    }
    /**
     * @dev Permit withdraw function only when 'stopped' is true
     * Circuit breaker pattern
     */    
    modifier onlyInEmergency { 
        require(stopped); _; 
    }    

    
    
    /// @dev Throws an error if the msg.sender is not the owner.
    modifier isAdmin () {
        require(owner == msg.sender);
        _;
    }

    /// @dev Throws an error if the msg.sender is not a hospital member.
    modifier isHospital () {
        require (bytes(hospitalMembers[msg.sender].name).length > 0);
        _;
    }

    /// @dev Throws an error if the msg.sender is not a prefecture member.
    modifier isPrefecture () {
        require (bytes(prefectureMembers[msg.sender].name).length > 0);
        _;
    }

    /// @dev Throws an error if the msg.sender is not a city hall member.
    modifier isCityHall () {
        require (bytes(cityHallMembers[msg.sender].name).length > 0);
        _;
    }

    /// @dev Contract constructor sets the owner
    constructor () public {
        owner = msg.sender;
    }    
  

    /**
     * @dev Changes stopped state variable to 'true'
     * Only the admin (owner) can call it
     * Circuit breaker pattern
     */
    function stopCivilStateContract() public isAdmin {
        stopped = true;
    }

    /**
     * @dev Withdraws contract balance to the owner's account
     * Only the admin (owner) can call it
     * Only possible when 'stopped' is true
     * Circuit breaker pattern
     */
    function withdraw() onlyInEmergency public {
        owner.transfer(address(this).balance);
    }

    /**
     * @dev Destroys contract and removes it from the blockchain
     * Only the admin (owner) can call it
     * Mortal pattern
     */
    function kill() public isAdmin {

        selfdestruct(address(uint160(owner))); // cast owner to address payable
    }

   
    /**
     * Admin functions
     */

    /// @dev Adds a hospital member.
    /// @param _newMember Address of the new member.
    /// @param _memberName Name of the new member.
    function addHospitalMember (address _newMember, string memory _memberName) public isAdmin {
        // Initialization of login
        string memory login = "login_";
        string memory _login = login.concatenate(_memberName);       
        hospitalMembers[_newMember] = Authentification({
            login : _login,
            name : _memberName
        });
        emit LogEventAddHospitalMember(_memberName);
    }

    /// @dev Adds a prefecture member.
    /// @param _newMember Address of the new member.
    /// @param _memberName Name of the new member.
    function addPrefectureMember (address _newMember, string memory _memberName) public isAdmin {
        // Initialization of login
        string memory login = "login_";
        string memory _login = login.concatenate(_memberName); 
        prefectureMembers[_newMember] = Authentification({
            login : _login,
            name : _memberName
        });
        emit LogEventAddPrefectureMember(_memberName);
    }

    /// @dev Adds a city hall member.
    /// @param _newMember Address of the new member.
    /// @param _memberName Name of the new member.
    function addCityHallMember (address _newMember, string memory _memberName) public isAdmin {
        // Initialization of login
        string memory login = "login_";
        string memory _login = login.concatenate(_memberName); 
        cityHallMembers[_newMember] = Authentification({
            login : _login,
            name : _memberName
        });
        emit LogEventAddCityHallMember(_memberName);
    }

    /*
        Function to add a new birth
        When there is a birth, a member of the hospital must declare the birth : this function creates a new birth
        Only a hospital member can create a new birth
    */
    /// @dev Adds a new birth.
    /// @param _name Birth name.
    /// @param _lastName Birth last name.
    /// @param _birthDate Birth date.
    /// @param _birthCity Birth city.
    /// @return birthId The birth identification.       
    function addBirth (string memory _name, string memory _lastName, string memory _birthDate, string memory _birthCity) public isHospital stopInEmergency returns(uint) {
        uint birthId = birthsCount;
        birthsCount = birthsCount.add(1);
        births[birthId] = Birth({
            name : _name,
            lastName : _lastName,
            birthDate : _birthDate,
            birthCity : _birthCity,
            isVerified : false
        });
        emit LogEventBirthAdded(_name, _lastName, birthId);
        return birthId;
    }

    // Function to get the birthId after the creation of a new birth
    function getBirthId () public view returns (uint _birthId, string memory _name, string memory _lastName){
        if (birthsCount == 0) {
          _birthId = birthsCount;  
        } else {
          _birthId = birthsCount.sub(1);  
        }
        _name = births[_birthId].name;
        _lastName = births[_birthId].lastName;
 
    }
    
    /*
        Function to verify an identity  
        After a birth declaration, the a member of the prefecture must verifiy the citizen's identity
        Only a member of the prefecture can verify an identity
    */
    function verifyIdentity (uint birthId) public isPrefecture stopInEmergency returns (uint identityId) {
        require(births[birthId].isVerified == false);
        births[birthId].isVerified = true;
        
        // Initialization of login and password
        string memory login = "login_";
        string memory _login = login.concatenate(births[birthId].lastName); 
        login = _login.concatenate(births[birthId].birthDate);        
        
        string memory pwd = "pwd_";
        string memory password = pwd.concatenate(births[birthId].birthDate);
        bytes32 passwordHash = keccak256(bytes(password));

        bytes32 lambdaCertification = keccak256(bytes("new"));

        //identityId = identitiesCount++;
        identityId = identitiesCount;
        identitiesCount = identitiesCount.add(1);
        identities[identityId] = Identity({
            birthinfo : births[birthId],
            maritalStatus : "single",
            marriageDate: "",
            userLogin: login
        });

        citizenIdentifiers[login] = Identifier({
            userIdentityCount : identityId,
            userPassword : passwordHash,
            newCertification : lambdaCertification
        });

        emit LogEventVerifyIdentity(birthId, identityId);
    }

    // Function to get the identityId after the verification of an identity
    function getIdentityId() public view returns (uint _identity, string memory _name, string memory _lastName){
        if (identitiesCount == 0) {
          _identity = identitiesCount;  
        } else {
          _identity = identitiesCount.sub(1);  
        }
        _name = identities[_identity].birthinfo.name;
        _lastName = identities[_identity].birthinfo.lastName; 
    }

    /*
        Function to declare a marriage
        Only a city Hall member can declare a marriage
    */
    function declareMarriage (uint identityId, string memory _marriageDate) public isCityHall stopInEmergency {
        require(identities[identityId].birthinfo.isVerified == true);
        
        //Change marital status
        identities[identityId].maritalStatus = "married";
        identities[identityId].marriageDate = _marriageDate;

        emit LogEventDeclareMarriage(_marriageDate, identityId);
    }

    /*
        Function to allow citizens to modify their password
    */
    function modifyMyPassword (string memory _login, string memory _oldPwd, string memory _newPwd) public{
        //Verify that the user used the good password
        require (citizenIdentifiers[_login].userPassword == keccak256(bytes(_oldPwd)));
        bytes32 newPwd = keccak256(bytes(_newPwd));
        citizenIdentifiers[_login].userPassword = newPwd;
    }

    /*
        Function to allow citizen to generete an identity certification
    */
    function generateIdCertification (string memory login, string memory pwd) public returns (bytes32){
        //Verify that the user used the good password
        require (citizenIdentifiers[login].userPassword == keccak256(bytes(pwd)));
        // Get the user identity count
        uint userIdCount = citizenIdentifiers[login].userIdentityCount;
        string memory userIdCountString = userIdCount.uintToString();
        string memory contIdentifiers = userIdCountString.concatenate(pwd);
        bytes32 identity_hash = keccak256(bytes(contIdentifiers));
        citizenIdentifiers[login].newCertification = identity_hash;
        // add certification to mapping
        idCertifications[identity_hash] = citizenIdentifiers[login];
        emit LogEventCertificationGenerated(login, identity_hash);
        return identity_hash;
    }
    
    // Function to get the lastCertification
    function getCertification(string memory _login) public view returns (bytes32) {
        return citizenIdentifiers[_login].newCertification;
    }
    

    /*
       Functions read
    */

    /*
        Function to verify identityCertification
        Once a citizen generates a certification, anyone who has the hash of the certification can verify the identity
    */

    function verifyCertification (bytes32 id_hash) public returns (string memory _name, string memory _lastName, string memory _birthDate, string memory _birthCity, string memory _maritalStatus) {
        // get userIdCount
        uint userIdCount = idCertifications[id_hash].userIdentityCount;
        emit LogEventVerifyCertification (identities[userIdCount].birthinfo.name, identities[userIdCount].birthinfo.lastName, identities[userIdCount].birthinfo.birthDate, identities[userIdCount].birthinfo.birthCity, identities[userIdCount].maritalStatus);
        return(identities[userIdCount].birthinfo.name, identities[userIdCount].birthinfo.lastName, identities[userIdCount].birthinfo.birthDate, identities[userIdCount].birthinfo.birthCity, identities[userIdCount].maritalStatus);

    }
    
    // Function to read a birth information
    function readBirth(uint birthId) public view returns(string memory _name, string memory _lastName, string memory _birthDate, string memory _birthCity, bool _isVerified){
        return (births[birthId].name, births[birthId].lastName, births[birthId].birthDate, births[birthId].birthCity, births[birthId].isVerified);
    }        

    // Function to read an identity information
    function readIdentity(uint identityId) public view returns(string memory _name, string memory _lastName, string memory _birthDate, string memory _birthCity, string memory _maritalStatus){
        require(identities[identityId].birthinfo.isVerified == true);
        return (identities[identityId].birthinfo.name, identities[identityId].birthinfo.lastName, identities[identityId].birthinfo.birthDate, identities[identityId].birthinfo.birthCity, identities[identityId].maritalStatus);
    }

    // Function to get the births count
    function getBirthsCount() public view returns(uint _birthCount) {
        return birthsCount; 
    }

    // Function to get the identities count
    function getIdentitiesCount() public view returns(uint _identitiesCount){
        return identitiesCount;
    }

    // Function to get the owner of the contract
    function getOwner() public view returns(address _owner){
        return owner;
    }

    /* 
        Function to verify if the msg.sender is a hospital member
        Return 0x00..0 if not a hospital member
        Return the address of the msg.sender if it is a hospital member
    */
    function isHospitalMember() public view returns(address){
        address memberAddress;
        if (bytes(hospitalMembers[msg.sender].name).length > 0) {
            memberAddress = msg.sender;
        } else {
            memberAddress = 0x0000000000000000000000000000000000000000;
        }
        return memberAddress;
    }

    /* 
        Function to verify if the msg.sender is a prefecture member
        Return 0x00..0 if not a prefecture member
        Return the address of the msg.sender if it is a prefecture member
    */
    function isPrefectureMember() public view returns(address){
        address memberAddress;
        if (bytes(prefectureMembers[msg.sender].name).length > 0) {
            memberAddress = msg.sender;
        } else {
            memberAddress = 0x0000000000000000000000000000000000000000;
        }
        return memberAddress;
    }

    /* 
        Function to verify if the msg.sender is a city hall member
        Return 0x00..0 if not a city hall member
        Return the address of the msg.sender if it is a city hall member
    */
    function isCityHallMember() public view returns(address){
        address memberAddress;
        if (bytes(cityHallMembers[msg.sender].name).length > 0) {
            memberAddress = msg.sender;
        } else {
            memberAddress = 0x0000000000000000000000000000000000000000;
        }
        return memberAddress;
    }

}